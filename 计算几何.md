## Andrew算法求凸包

```cpp
int n;
const int maxn;
struct Point{
   double x,y;
};
Point p[maxn],ch[maxn];    //后者记录凸包上的点

bool cmp(Point x,Point y)
{
    return x.x<y.x||(x.x==y.x&&x.y<y.y);//x从小到大排序，如果x相同则y从小到大排序
}
int Cross(Point x,Point y,Point z)
{
    double x1=x.x-y.x;
    double y1=x.y-y.y;
    double x2=z.x-y.x;
    double y2=z.y-y.y;
    if((x1*y2-x2*y1)<=0) return 0;//如果不希望在凸包的边上有输入点。把<=改成<
    return 1;
}
void andrew()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%lf %lf",&p[i].x,&p[i].y);
    sort(p,p+n,cmp);
    int m=0;
    int i;
    for(i=0;i<n;i++)//从左到右扫描
    {
        while( m>1 && !Cross(ch[m-1],ch[m-2],p[i])) m--;
        ch[m++]=p[i];
    }
    int k=m;
    for(i=n-2;i>=0;i--)//从右到左扫描
    {
        while( m>k && !Cross(ch[m-1],ch[m-2],p[i])) m--;
        ch[m++]=p[i];
    }
    if(n>1) m--;//凸包有m个顶点
    int ans=m;
    double sum=0;//周长
    for(int i=0;i<ans-1;i++){
        sum+=sqrt((ch[i+1].x-ch[i].x)*(ch[i+1].x-ch[i].x)+(ch[i+1].y-ch[i].y)*(ch[i+1].y-ch[i].y)); //算周长
    }
    sum+=sqrt((ch[ans-1].x-ch[0].x)*(ch[ans-1].x-ch[0].x)+(ch[ans-1].y-ch[0].y)*(ch[ans-1].y-ch[0].y));//最后还有第n个点到第1个点的距离
    printf("%.2lf",sum);
}
```
